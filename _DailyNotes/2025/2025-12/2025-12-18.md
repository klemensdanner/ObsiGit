---
Arbeitszeit: 2
---

## Important notes

#prüfung #progprüfung 
Prüfung PROG
90 min
1. durchlesen
2. einfach - schwer lesen

Stoff:
- Feinanalyse eher nicht aber nicht ausgeschlossen
- Felder, Listen und Bäume natürlich fix
- Ideen der Sortierverfahren & evtl. auch schreiben
- Angaben sind im Pseudocode
	- wir können pascal schreiben
- sowas wie wieviele Bits hat in Integer in pascal, aber nicht in der klausur
- Darstellungsarten  eher nicht
- 7 Strukuturkomplexität, essenzielle Strukturkomplexität


1 Gundlagen
2 Spezifikation nicht sinnvoll für prüfung
3 alles relevant
4 Plan was schrittweise verfeinerung etc
5 algo mit gedächtnis - static variable gibts in 
6 dynam. Daten: großer Teil der struktur
- doppelt verkettet mit zyklisch und Anker kommt nicht
- einfach und doppelte Listen kommen nicht
- bei Bäumen: wesentlich sind binäre Bäume und binäre Suchbäume
7 Rekursion
Funktionale Programmierung kommt nicht
Allgmeines Schema zum Umwandeln von Rekursion in Iterativ kommt nicht - zu aufwändig

8 Komplexität
- z.B. Algo gegeben und Kompl. analysieren
- asympthotische Komplexität gut, fein eher nicht aber td können

9 Sortieralgos
- grundsatzideen checken, merge sort weglassen, alle anderen schon
- z.B. Grundidee von Shellsort auf Basis von insertionsort verbessern
- Feld mit Elementen, Umordnen im Sinne von Quicksort für einen günstigen Fall an einem Feld zeigen
- Laufzeitkomplexitäten kennen, auch z.B. Abhängigkeit von Vorsortierungen etc.
- weitere sortierverfahren kommen nicht
- Stabilität von Sortierverfahren kommt
- topologisches Sortieren kommt nicht

Allgemein:

- Alles gemeinsam sind 8 Fragen
- Die ersten 10 Minuten sind Fragen erlaubt, dann keine Fragen mehr!
- Genau lesen: z.B. wenn iterativer Algo gefordert ist, dann nicht rekursiv machen! ansonsten
- Nie Schnittstellen ändern
- Spezifikation ist vollständig, wenn Aufgabe erfüllt, dann passts. Nichts lösen was nicht explizit gefordert ist
	- Programm muss allerdings immer robust sein!
	- Wenn spezielle Infos gegeben sind (z.B. Feld ist bereits sortiert), dann soll man diese Infos auch verwenden für eine effizientere Lösung
- Tipp: Skizze machen zum verstehen
- irgendeine Aufgabe kommt, wo man eine Datenstruktur zeichnen muss - wichtig
- wenns ein Kriterium gegeben ist, dann soll man das auch verwenden (z.B. wenn steht dass es eine sortierte Liste ist, dann das auch verwenden)
- Wenn eine Lösung sehr weit von einer effizienten Lösung entfernt ist, gibts Abzug
- Struktur: nicht erwartet: alles perfekt machen, aber wenn ganz schiach, dann gibts Abzug
- genau lesen: Binärbaum vs. binärer Suchbaum
- Übungsmaterial: im Lehrbuch sind Klausuraufgaben





## Tasks
```tasks
not done
```


[[_Global Note]]


```timekeep
{"entries":[{"name":"Block 1","startTime":"2025-12-21T16:43:28.000Z","endTime":"2025-12-21T18:43:29.000Z","subEntries":null}]}
```

```dataviewjs
const file = Array.isArray(dv.current().file.path) ? dv.current().file.path[0] : dv.current().file.path;
const tFile = app.vault.getAbstractFileByPath(file);

// 1. Gesamte Datei einlesen
const content = await app.vault.read(tFile);

// 2. Timekeep Block suchen & parsen
const timekeepMatch = content.match(/```timekeep\s+([\s\S]*?)\s+```/);

if (timekeepMatch) {
    const data = JSON.parse(timekeepMatch[1]);
    let totalMs = 0;

    // Logik für Entries und SubEntries
    data.entries.forEach(e => {
        if (e.startTime && e.endTime) totalMs += (new Date(e.endTime) - new Date(e.startTime));
        if (e.subEntries) {
            e.subEntries.forEach(s => {
                if (s.startTime && s.endTime) totalMs += (new Date(s.endTime) - new Date(s.startTime));
            });
        }
    });

    const totalHours = parseFloat((totalMs / 3600000).toFixed(2));

    // 3. Frontmatter aktualisieren, falls der Wert abweicht
    await app.fileManager.processFrontMatter(tFile, (frontmatter) => {
        if (frontmatter["Arbeitszeit"] !== totalHours) {
            frontmatter["Arbeitszeit"] = totalHours;
            console.log(`Sync: Arbeitszeit auf ${totalHours}h aktualisiert.`);
        }
    });

    dv.paragraph(`✅ **Timekeep Sync aktiv:** ${totalHours}h übertragen.`);
}
```
