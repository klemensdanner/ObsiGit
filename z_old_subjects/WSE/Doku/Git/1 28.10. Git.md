
WH:
#flashcards/wse/git
Wie erlangt man root-rechte in der bash::{
```bash
sudo su // nur switch user

sudo -i // Neuanmeldung als root
```
}

### Git

```bash
$ git init -b main
Initialized empty Git repository in C:/Public/wse-ws25/shopping-list/.git/

//Erklärung
-- erstellt einen .git Unterordner

/shopping-list       // git workspace [gesamter Ordner mit repo + workingDir]
	|___  .git       // Repository
	|___  List.txt   // WorkingDir (alle Files außerhalb .git)
```



### Settings
```
//Systemweite Einstellungen liegen im Installationsverzeichnis /etc/gitconfig
SYSTEM

// kann für sich anpassen
USER

//kann lokale Einstellungen treffen
LOCAL
```



Beispiel ```

```bash
$ git config -l --show-origin //show-origin: Zeigt Herkunft. wow. :D

file:C:/Program Files/Git/etc/gitconfig diff.astextplain.textconv=astextplain
file:C:/Program Files/Git/etc/gitconfig filter.lfs.clean=git-lfs clean -- %f
file:C:/Program Files/Git/etc/gitconfig filter.lfs.smudge=git-lfs smudge -- %f
file:C:/Program Files/Git/etc/gitconfig filter.lfs.process=git-lfs filter-process
file:C:/Program Files/Git/etc/gitconfig filter.lfs.required=true
file:C:/Program Files/Git/etc/gitconfig http.sslbackend=schannel
file:C:/Program Files/Git/etc/gitconfig core.autocrlf=true
file:C:/Program Files/Git/etc/gitconfig core.fscache=true
file:C:/Program Files/Git/etc/gitconfig core.symlinks=false
file:C:/Program Files/Git/etc/gitconfig pull.rebase=false
file:C:/Program Files/Git/etc/gitconfig credential.helper=manager
file:C:/Program Files/Git/etc/gitconfig credential.https://dev.azure.com.usehttppath=true
file:C:/Program Files/Git/etc/gitconfig init.defaultbranch=master
file:.git/config        core.repositoryformatversion=0
file:.git/config        core.filemode=false
file:.git/config        core.bare=false
file:.git/config        core.logallrefupdates=true
file:.git/config        core.symlinks=false
file:.git/config        core.ignorecase=true
```


Git Befehle werden verwendet, um Usereinstellungen/Local Einstellungen zu verändern.
Kann man auch in Textdateien im Ordner ändern, bei einem Fehler führt das aber zu Problemen


```bash
|-- M <-- H //Head zeigt auf Main, main zeigt nirgendwohin

// 'On branch Main'
```



Erstellt wird beispielsweise eine Datei 'List.txt'.
Git status liefert:

```bash
$ git status
On branch main

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        list.txt

nothing added to commit but untracked files present (use "git add" to track)

// ---- list.txt ist noch nicht in der Index/Staging area

```


#### Staging Area
Es werden nur Files in eine neue Version im repo commitet, wenn sie im Index/stagingArea referenziert sind.
Wenn Unterschiede zwischen working Directory und der stagingArea existieren, führt das zu dem obigen Fehler.
Wir müssen also die Datei List.txt an die StagingArea referenzieren

```bash
$ git add list.txt
warning: in the working copy of 'list.txt', LF will be replaced by CRLF the next time Git touches it

kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   list.txt

```

Jetzt ist die File in der Staging Area.
Jetzt kann man commiten - Damit wird im Repository die erste Version erstellt.
Dabei wird im Repo gespeichert

D.H.:


Die Files sind einmal im WorkingDir gespeichert und einmal binär im repository.

Beim adden der file in die staging area wird die Datei binär im repo gespeichert, beim commiten wird eine neue Version erstellt und der tree mit der binären file connected (mit diesen gehashten referenznummern)


```bash
$ git log -p //damit werden alle Versionen angezeigt, welche vom Main aus erreichbar sind

commit cb90c16a668df716b3133e2a8bffc33ecb4b2319 (HEAD -> main)
Author: klemens <klemens.danner@gmx.at>
Date:   Tue Oct 28 09:28:24 2025 +0100

    Initial commit

diff --git a/list.txt b/list.txt
new file mode 100644
index 0000000..8e89ffd
--- /dev/null
+++ b/list.txt
@@ -0,0 +1,2 @@
+aepfel
+birnen


```


Man kann Alias setzen:
```bash
kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git log --graph --oneline --decorate --all
* cb90c16 (HEAD -> main) Initial commit

kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git config --global alias.graph 'log --graph --oneline --decorate --all'

kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ ^C

kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git graph
* cb90c16 (HEAD -> main) Initial commit

```


passt.

Jetzt File mit Nano verändern

```bash
kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   list.txt

no changes added to commit (use "git add" and/or "git commit -a")



kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git diff
warning: in the working copy of 'list.txt', LF will be replaced by CRLF the next time Git touches it
diff --git a/list.txt b/list.txt
index 8e89ffd..f730a3d 100644
--- a/list.txt
+++ b/list.txt
@@ -1,2 +1,4 @@
 aepfel
 birnen
+bier
+lebakaaas

```




Git restore

```bash
git restore -S //nimmt die Version vom repo und schiebt sie in den Index

git restore -W / git restore // nimmt Version vom Index und schiebt in ins Working Dir
```



#important #prüfung Leere Verzeichnisse können nicht versioniert werden! Deshalb brauchen wir eine versteckte Datei z.B. mit .gitkeep


File Umbenennen
```bash
mv list.txt shopping.txt

//
Dann gibt er aus, dass list.txt deleted wurde und shopping.txt untracked file ist.

Nach einem git add, erkennt er, dass die Datei nur umbenannt wurde
```

Besser zum umbenennen ist aber:
``
```bash
git mv list.txt shopping.txt

//gibt er zurück: file renamed und checkts.
```



Den Index könnte man cleanen, indem man das file im WorkingDir löscht und dann zum Status added, also mit 
```bash
rm list.txt && git add list.txt
```
Das geht auf einmal mit
```bash
git rm list.txt && git add list.txt
```



### Git diff
Git diff zeigt Unterschied zwischen Index und WorkingDir

Git diff --cached zeigt Unterschied zwischen Repo und Index
```bash
kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git diff //Kein Unterschied zwischen Index und WD

kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git diff --cached
diff --git a/list.txt b/list.txt
index f730a3d..9ee20aa 100644
--- a/list.txt
+++ b/list.txt
@@ -2,3 +2,6 @@ aepfel
 birnen
 bier
 lebakaaas
+chips
+wurst
+kaese
```


### Dateien ausschließen (z.B. ausführbare files will man nicht versionieren!)

Das macht man mit .gitignore file, das man einfach mit touch erstellt

```bash
$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   list.txt

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        lib/
        tmp.txt

```

Diese files (lib und tmp) wollen wir nicht versionieren.
Also erstellen wir im WD eine Datei mit dem Namen .gitignore
```bash
$ touch .gitignore

git add .gitignore && git commit -m 'add gitignore'
Dann wird das committed und berücksichtigt



kleme@Klemens MINGW64 /c/Public/wse-ws25/shopping-list (main)
$ git status --ignored
On branch main
Ignored files:
  (use "git add -f <file>..." to include in what will be committed)
        lib/
        tmp.txt

nothing to commit, working tree clean
```


Fast forward merge --> wenn in der Quelle auch alle Einträge des Ziels vorhanden sind, kann die Datei einfach zusammengefügt werden

rebase nächstes mal