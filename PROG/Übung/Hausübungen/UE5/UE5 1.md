- [x] #prog UE5 üìÖ 2025-11-26 ‚è≥ 2025-11-21 ‚è´ [[PRO1UEA05 VZ.pdf]] ‚úÖ 2025-11-23

## 1 Schnittmengen

### 1.1 L√∂sungsidee
Es soll eine Funktion implementiert werden, welche pr√ºft, ob die Werte aufsteigend sortiert sind. Das wird so realisiert, dass jeder Wert im Array mit seinem Nachfolger verglichen wird.
Dann wird die Hauptfunktion Intersect() erstellt. Eine einfache L√∂sung w√§re es, die beiden arrays immer wieder zu durchlaufen um zu ermitteln, ob die Werte in beiden Arrays vorkommen. Weil die Arrays sortiert sind m√∂chte ich aus Effizienzgr√ºnden einen anderen Algorithmus bauen.
Dabei sollen die Arrays nur einmal durchlaufen werden. In einer Schleife 



Das soll in zwei verschachtelten While-Schleifen passieren. Die √§u√üere Schleife durchl√§uft das k√ºrzere Array, da der Algorithmus beendet wird, sobald das k√ºrzere Array durchlaufen ist.
Am Anfang von beiden Schleifen, sollen gleiche Werte √ºbersprungen werden. Dann werden die Werte verglichen. Wenn gleich, dann kommt der Wert ins Zielarray. Wenn ungleich, wird der Index des kleineren Wertes inkrimentiert (gleiche Werte wieder √ºberspringen) und erneut verglichen. Solange, bis das k√ºrzere Array durchgelaufen ist.

### 1.2 Quellcode

```pascal
program schnittmenge;

const
	max = 100;

type
	IntArray = array[1..max] of integer;

function IsSorted(a: Array of integer; n: integer): boolean;
var
	i: integer;
	sorted: boolean;

begin
	i := 0; //OpenArray-Init
	while sorted AND i <= (n-2) do //Zugriff auf i+1 & open-array
		begin
			if a[i] <= a[i+1] then
				sorted := true
			else
				sorted := false;
			
			i := i + 1;
		end; //end while
	
	IsSorted := sorted;
end;

procedure Intersect(a1: array of integer; n1: integer; a2: array of integer; n2: integer; VAR a3: array of integer; VAR n3: integer);

VAR
	i, j: integer;

begin
	//Eingangskriterien pr√ºfen
	if (NOT IsSorted(a1, n1)) OR (NOT IsSorted(a2, n2)) then
		begin
			n := -1;
			Exit; //Prozedur wird wegen Nichterf√ºllung der Eingangskriterien verlassen
		end;
	
	while i <= (n-1)



end;


//save
  //a1 beginnnen
	while (i <= (n1-2)) AND NOT InnerArrayEnd do //-2 checken!
    begin
      //gleiche Zahlen √ºberspringen:
      while a1[i] = a1[i+1] do
        i := i + 1;
      while a2[j] = a2[j+1] do
        j := j + 1;
      

      //a2: inneres Array 'langsam' durchlaufen
      while (j <= (n2-1)) AND (CONDITION) do //!!!
        begin



```


```pascal
program schnittmenge;

const
	max = 100;

type
	IntArray = array[1..max] of integer;


procedure ReadArray(var a: Array of integer; n: integer);
var
  i: integer;

begin
  for i := 0 to (n-1) do
    Read(a[i]);
end;

procedure WriteArray(a: Array of integer; n: integer);
var
  i: integer;
begin
  for i := 0 to (n-1) do
    Write(a[i]:3);
end;


function IsSorted(a: Array of integer; n: integer): boolean;
var
	i: integer;
	sorted: boolean;

begin
	i := 0; //OpenArray-Init
  sorted := true;
	while sorted AND (i <= (n-2)) do //Zugriff auf i+1 & open-array
		begin
      if a[i] > a[i+1] then
        sorted := false;

			i := i + 1;
		end; //end while
	
	IsSorted := sorted;
end;


procedure Intersect(a1: array of integer; n1: integer; a2: array of integer; n2: integer; VAR a3: array of integer; VAR n3: integer);

VAR
	i, j: integer;

begin
	//Eingangskriterien pr√ºfen
	if (NOT IsSorted(a1, n1)) OR (NOT IsSorted(a2, n2)) then
		begin
			n3 := -1;
			Exit; //Prozedur wird wegen Nichterf√ºllung der Eingangskriterien verlassen
		end;
	
  i := 0;
  j := 0; //open-array-init
  n3 := 0; //init

  while (i <= (n1 - 1)) AND (j <= (n2 - 1)) do
    begin
      //gleiche Zahlen √ºberspringen:
      while (i <= (n1-2)) AND (a1[i] = a1[i+1]) do //pr√ºfung damit i+1 nicht au√üerhalb liegt
        i := i + 1;
      while (j <= (n2-2)) AND (a2[j] = a2[j+1]) do
        j := j + 1;
      
      if (a1[i] = a2[j]) then
        begin
          a3[n3] := a1[i];
          i := i + 1;
          j := j + 1;
          n3 := n3 + 1;
        end
      else
        if (a1[i] < a2[j]) then
          i := i + 1
        else
          j := j + 1;

      WriteLn('n3 > ', n3);
    end;
end;


VAR
  a1, a2, a3: IntArray;
  n1, n2, n3 : integer;


begin
  WriteLn('n1 > ');
  Read(n1);

  WriteLn('Enter ', n1, ' values > ');
  ReadArray(a1, n1);
  WriteArray(a1, n1);
  WriteLn;

  WriteLn('n2 > ');
  Read(n2);

  WriteLn('Enter ', n2, ' values > ');
  ReadArray(a2,n2);
  WriteArray(a2,n2);

  Intersect(a1, n1, a2, n2, a3, n3);
  WriteLn;
  WriteArray(a3, n3);
  WriteLn;

end.

```

## 2 Zeichenkettenverarbeitung

### L√∂sungsidee
In der Funktion WithoutLastChar wird die Standardfunktion Copy verwendet.

```pascal
function WithoutLastChar(s: string): string;
begin
	WithoutLastChar := copy(s, (length(s)-1), 1);
end;
```

c) 
Array durchlaufen und jeweils String zusammensetzen. Vor der Addition immer Gesamtl√§nge √ºberpr√ºfen (damit die Zeichenkette in einen String geht) und auch mit implementierter Funktion den hinzuzuf√ºgenden string iterieren und schauen dass nur g√ºltige zeichen drin sind und gleich die gro√ü und Kleinschreibung anpassen.

Nach der Schleife wird abh√§ngig vom Stand der Z√§hlvariable entschieden, ob die Zeichenkette g√ºltig ist - dann wird sie ausgegeben, oder ob sie ung√ºltig ist (weil nicht das ganze array of string durchlaufen wurde) - dann wird der R√ºckgabewert auf "error" gesetzt.








# Kaffeeautomat

## L√∂sungsidee

zu deklarierende Funktionen:
TotalValue(Coin): integer; Gesamtwert der M√ºnzen

R√ºckgeld(Coin): Coin; zur√ºckzugebendes R√ºckgeld, wenn nicht verf√ºgbar werden alle 3 Werte auf -1 gesetzt

Mittels Record soll der Datentyp "Coin" definiert werden.
Eine Variable zur Speicherung des gesamten M√ºnzbestands wird definiert.

Die Anzahl der eingeworfenen M√ºnzen verschiedener Typen wird eingelesen.
Dann wird aufgefordert 'coffee' einzugeben, um den Algorithmus zu starten.

In der Prozedur wird TotalValue(input) < 40 gepr√ºft, wenn das true ist, dann
	change := input; // das eingeworfene Geld wird also zur√ºckgegeben
	Exit;

Wenn TotalValue(coin) >= 40, dann
	R√ºckgeld() aufrufen
		wenn Werte < 0 dann
			inc(CounterNoChange)
			wenn CounterNoChange >= 3 dann "out of order"
			Exit;
	OutputCoffee()
	change := R√ºckgeld()



### Unit

```pascal
UNIT Kaffeeautomat_unit;

INTERFACE
  type
    Coins = record
      cent10: integer;
      cent50: integer;
      cent100: integer;
  end;

  procedure ReadCoins(VAR c: Coins);
  procedure WriteCoins(c: Coins);

  procedure CoffeeButtonPressed(input: Coins; VAR change: Coins);

IMPLEMENTATION

  var
    totalCoins: Coins;
    noChangeCounter: integer;

  procedure ReadCoins(VAR c: Coins);
  begin
    Write('10 cent coins > '); ReadLn(c.cent10);
    Write('50 cent coins > '); ReadLn(c.cent50);
    Write('100 cent coins > '); ReadLn(c.cent100);
  end;

  procedure WriteCoins(c: Coins);
  begin
    WriteLn('10 cent coins > ', c.cent10);
    WriteLn('50 cent coins > ', c.cent50);
    WriteLn('100 cent coins > ', c.cent100);
  end;

  function AddCoins(a, b: Coins): Coins;
    begin
      AddCoins.cent10 := a.cent10 + b.cent10;
      AddCoins.cent50 := a.cent50 + b.cent50;
      AddCoins.cent100 := a.cent100 + b.cent100;
    end;

  function SubtractCoins(a, b: Coins): Coins;
  begin
    SubtractCoins.cent10 := a.cent10 - b.cent10;
    SubtractCoins.cent50 := a.cent50 - b.cent50;
    SubtractCoins.cent100 := a.cent100 - b.cent100;
  end;

  

  function TotalValue(c: Coins): integer;
  begin
    TotalValue := c.cent10*10 + c.cent50*50 + c.cent100*100;
  end;

  function CalcChange(c: Coins; VAR error: boolean): Coins;
    var
      change: Coins;
      ValueOfChange: integer;
  
  begin

    change.cent100 := 0; //init
    change.cent50 := 0;
    change.cent10 := 0;

    totalCoins := AddCoins(totalCoins, c); //Eingabe zu Totalcoins addieren, zum Stand aktualisieren

    ValueOfChange := TotalValue(c)-40; //Kaffeepreis

    change.cent100 := change.cent100 + (ValueOfChange div 100);
    ValueOfChange := ValueOfChange mod 100; //Rest f√ºr die anderen M√ºnzen
    while change.cent100 > totalCoins.cent100 do begin
      dec(change.cent100);
      change.cent50 := change.cent50 + 2;
    end; (*while*)

    change.cent50 := change.cent50 + (ValueOfChange div 50);
    ValueOfChange := ValueOfChange mod 50; //Rest
    while change.cent50 > totalCoins.cent50 do begin
      dec(change.cent50);
      change.cent10 := change.cent10 + 5;
    end; (*while*)

    change.cent10 := change.cent10 + (ValueOfChange div 10);

    if change.cent10 > totalCoins.cent10 then begin
      error := true;
      inc(noChangeCounter);
      totalCoins := SubtractCoins(totalCoins, c);
      CalcChange := c;
    end else begin
      totalCoins := SubtractCoins(totalCoins, change);
      error := false;
      noChangeCounter := 0;
      CalcChange := change;
    end; (*if*)
  end;

  procedure CoffeeButtonPressed(input: Coins; VAR change: Coins);
    var
      error: boolean;
  begin

    If noChangeCounter >= 3 then begin
      change := input;
      WriteLn('Error - out of service (not enough coins)');
      //WriteLn('R√ºckgeld: ', change);
      Exit;
    end;

    if TotalValue(input) < 40 then begin
      change := input;
      WriteLn('Zu wenig Geld, gibts keinen Kaffee. :(');
      //WriteLn('R√ºckgeld: ');
      //WriteCoins(change);
      Exit;
    end; (*if*)

    change := CalcChange(input, error);

    if error then begin //error: kein Wechselgeld
      WriteLn('Sorry, nicht genug Rueckgeld. Du bekommst dein Geld zurueck');
      WriteLn()
    end else
      WriteLn('Kaffeeeeee!');
  end;


//Initialisation, only first time
BEGIN
  //Wechselgeld
  totalCoins.cent10 := 10;
  totalCoins.cent50 := 5;
  totalCoins.cent100 := 0;

  noChangeCounter := 0;
END.
```


## Hauptprogramm
```pascal
program Kaffeeautomat_usingUnit;

USES
  Kaffeeautomat_unit;

var
  input: Coins;
  change: Coins;
  userInteraction: string;
  moreCoffee: boolean;


begin

  moreCoffee := true; //init

  while moreCoffee do begin

    WriteLn('Enter your input: ');
    ReadCoins(input);

    CoffeeButtonPressed(input, change);
    WriteLn;

    WriteLn('Here is your change: ');
    WriteCoins(change);

    WriteLn;

    WriteLn('Do you want another coffee? (y/n)');
    ReadLn(userInteraction);

    if (Length(userInteraction) > 0) AND ((userInteraction[1] = 'y') OR (userInteraction[1] = 'Y')) then
      moreCoffee := true
    else
      moreCoffee := false;

  end; (*while*)

end.
```















```pascal
program Kaffeeautomat;

  type
    Coins = record
      cent10: integer;
      cent50: integer;
      cent100: integer;
  end;

  var
    totalCoins: Coins;
    noChangeCounter: integer;

  procedure ReadCoin(VAR c: Coins);
  begin
    Write('10 cent coin > '); ReadLn(c.cent10);
    Write('50 cent coin > '); ReadLn(c.cent50);
    Write('100 cent coin > '); ReadLn(c.cent100);
  end;

  function AddCoins(a, b: Coins): Coins;
    begin
      AddCoins.cent10 := a.cent10 + b.cent10;
      AddCoins.cent50 := a.cent50 + b.cent50;
      AddCoins.cent100 := a.cent100 + b.cent100;
    end;

  function TotalValue(c: Coins): integer;
  begin
    TotalValue := c.cent10*10 + c.cent50*50 + c.cent100*100;
  end;

  function CalcChange(c: Coins): Coins;
    var
      change: Coins;
      ValueOfChange: integer;
  
  begin

    change.cent100 := 0; //init
    change.cent50 := 0;
    change.cent10 := 0;

    totalCoins := AddCoins(totalCoins, c); //Eingabe zu Totalcoins addieren, zum Stand aktualisieren

    ValueOfChange := TotalValue(c)-40;

    change.cent100 := change.cent100 + (ValueOfChange div 100);
    ValueOfChange := ValueOfChange mod 100; //Rest f√ºr die anderen M√ºnzen
    while change.cent100 > totalCoins.cent100 do begin
      dec(change.cent100);
      change.cent50 := change.cent50 + 2;
    end; (*while*)

    change.cent50 := change.cent50 + (ValueOfChange div 50);
    ValueOfChange := ValueOfChange mod 50; //Rest
    while change.cent50 > totalCoins.cent50 do begin
      dec(change.cent50);
      change.cent10 := change.cent10 + 5;
    end; (*while*)

    change.cent10 := change.cent10 + (ValueOfChange div 10);

    if change.cent10 > totalCoins.cent10 then begin
      WriteLn('ERROR: Out of order! (no coins left)');
      inc(noChangeCounter);
      CalcChange := c;
    end else
      CalcChange := change;
  end;

  procedure CoffeeButtonPressed(input: Coins; VAR change: Coins);
  begin
    















  end;










  var
    inputCoins: Coins;

begin
  //noChangeCounter initialisieren
  noChangeCounter := 0;
  Write('TotalCoins > '); WriteLn;
  ReadCoin(totalCoins);

  Write('inputCoins > ');
  ReadCoin(inputCoins);

  WriteLn;

  WriteLn('calculated change: ');
  WriteLn('nr. of 10cent coins: ', calcChange(inputCoins).cent10);
  WriteLn('nr. of 50cent coins: ', calcChange(inputCoins).cent50);
  WriteLn('nr. of 100cent coins: ', calcChange(inputCoins).cent100);



end.
```