## 1 Schnittmengen

### 1.1 Lösungsidee
Es soll eine Funktion implementiert werden, welche prüft, ob die Werte aufsteigend sortiert sind. Das wird realisiert, indem jeder Wert mit seinem Nachfolger verglichen wird.
In der Funktion Intersect wird am Anfang geprüft, ob die übergebenen Arrays sortiert sind. Wenn dies der Fall ist, startet der eigentliche Algorithmus.
Dabei sollen die Arrays nur einmal durchlaufen werden.
In einer Schleife wird immer geprüft, ob die Einträge der beiden Arrays gleich sind. Wenn dies der Fall ist und im Zielarray genügend Platz ist, wird die Zahl in das Ausgangsarray gespeichert und beide Indizes werden erhöht.
Falls die Einträge ungleich sind, wird der Index der kleineren Zahl inkrimentiert.
Der Vorgang wird so lange wiederholt, bis eines der Arrays vollständig durchlaufen wurde.

<div class="page-break" style="page-break-before: always;"></div>

### 1.2 Quellcode

```pascal
PROGRAM Schnittmenge;

  CONST
    max = 100;

  TYPE
    IntArray = ARRAY[1..max] OF INTEGER;

  PROCEDURE ReadArray(VAR a: ARRAY OF INTEGER; n: INTEGER);
    VAR
      i: INTEGER;

  BEGIN
    FOR i := 0 TO (n-1) DO
      Read(a[i]);
  END;

  PROCEDURE WriteArray(a: ARRAY OF INTEGER; n: INTEGER);
    VAR
      i: INTEGER;
  BEGIN
    FOR i := 0 TO (n-1) DO
      Write(a[i]:3);
  END;

  FUNCTION IsSorted(a: ARRAY OF INTEGER; n: INTEGER): BOOLEAN;
    VAR
      i: INTEGER;
      sorted: BOOLEAN;

  BEGIN
    i := 0; (*OpenArray-Init*)
    sorted := TRUE;
    WHILE sorted AND (i <= (n-2)) DO BEGIN (*Zugriff auf i+1 & open-array*)
      IF a[i] > a[i+1] THEN
        sorted := FALSE;
      i := i + 1;
    END; (*end while*)
    IsSorted := sorted;
  END;

  PROCEDURE Intersect(a1: ARRAY OF INTEGER; n1: INTEGER; a2: ARRAY OF INTEGER; n2: INTEGER; VAR a3: ARRAY OF INTEGER; VAR n3: INTEGER);
    VAR
      a3max, i, j: INTEGER;
  BEGIN
    (*Eingangskriterien prüfen*)
    IF (NOT IsSorted(a1, n1)) OR (NOT IsSorted(a2, n2)) THEN BEGIN
      n3 := -1;
      Exit;
    END;
    
    a3max := high(a3);
    i := 0;
    j := 0; (*open-array-init*)
    n3 := 0; (*init*)

    WHILE (i <= (n1 - 1)) AND (j <= (n2 - 1)) DO BEGIN   
      IF (a1[i] = a2[j]) THEN BEGIN
        IF n3 <= a3max THEN BEGIN
          a3[n3] := a1[i];
          i := i + 1;
          j := j + 1;
          n3 := n3 + 1;
        END ELSE BEGIN   
          n3 := -1;
          Exit; (*Überlauf*)
        END
      END ELSE
        IF (a1[i] < a2[j]) THEN
          i := i + 1
        ELSE
          j := j + 1;
    END; (*WHILE*)
  END;

  VAR
    a1, a2, a3: IntArray;
    n1, n2, n3 : INTEGER;


BEGIN
  Write('n1 > ');
  Read(n1);

  Write('Enter ', n1, ' values > ');
  ReadArray(a1, n1);
  WriteArray(a1, n1);
  WriteLn;

  Write('n2 > ');
  Read(n2);

  Write('Enter ', n2, ' values > ');
  ReadArray(a2,n2);
  WriteArray(a2,n2);

  Intersect(a1, n1, a2, n2, a3, n3);

  IF (n3 = -1) THEN
    WriteLn('An Error occured: input arrays not sorted or overflow')
  ELSE BEGIN
    WriteLn('Those numbers are in both arrays: ');
    WriteArray(a3, n3);
    WriteLn;
  END; (*IF*)

END.

```

<div class="page-break" style="page-break-before: always;"></div>
### 1.3 Tests

| Eingabe          | Begründung                                                                                 | Ausgabe                                   |
| ---------------- | ------------------------------------------------------------------------------------------ | ----------------------------------------- |
| siehe Screenshot | mehrere gleiche Zahlen                                                                     | ![[Pasted image 20251122201825.png\|250]] |
| siehe Screenshot | keine gleichen Zahlen,<br>no message is a good one;<br>Zielarray leer, deshalb kein Output | ![[Pasted image 20251122202003.png\|250]] |
| 0                | 0                                                                                          | ![[Pasted image 20251122202139.png\|250]] |
| siehe Screenshot | nicht sortiert                                                                             | ![[Pasted image 20251122202323.png\|250]] |
| siehe Screenshot | temporär ein Output-Array mit der Länge 5 übergeben, um einen overflow zu triggern         | ![[Pasted image 20251122202630.png\|250]] |

<div class="page-break" style="page-break-before: always;"></div>

## 2 Zeichenkettenverarbeitung

### 2.1 Lösungsidee
In der Funktion WithoutLastChar wird die Standardfunktion Copy verwendet.
In der Funktion EqualsIgnoreCase wird die Standardfunktion Upcase verwendet, um beide strings in deren Großbuchstabenschreibweise zu vergleichen.

Die Funktion camelCase wird folgendermaßen realisiert:
Konzeptionell soll in einer Schleife in jedem Schleifendurchlauf ein neues Wort zum Ausgangsstring hinzugefügt werden.
In einem Schleifendurchlauf werden zuerst zwei Abbruchbedingungen geprüft und ggf. wird der Rückgabewert auf 'Error' gesetzt und die Funktion verlassen.
Danach wird bei jedem Wort der erste Buchstabe groß und die restlichen klein geschrieben. (nur der allererste Buchstabe bleibt klein)
Anschließend wird das modifizierte Wort zum Ergebnisstring hinzugefügt.

<div class="page-break" style="page-break-before: always;"></div>

### 2.2 Quellcode
```pascal
PROGRAM Zeichenkettenverarbeitung;
  CONST
    max = 100;

  PROCEDURE ReadStringArray(VAR a: ARRAY OF STRING; VAR n: INTEGER);
    VAR
      i: INTEGER;
  BEGIN
    Write('Anzahl der einzulesenden Woerter > ');
    Readln(n);
    WriteLn('Gib die ', n, ' Woerter ein: ');
    FOR i := 0 TO (n-1) DO BEGIN
      Write((i+1), '. > ');
      ReadLn(a[i]);
    END; (*for*)
  END;

  FUNCTION WithoutLastChar(s: STRING): STRING;
  BEGIN
	  WithoutLastChar := copy(s, 1, (length(s)-1));
  END;

  FUNCTION EqualsIgnoreCase(a, b: STRING): BOOLEAN;
  BEGIN
    IF (Upcase(a) = Upcase(b)) THEN
      EqualsIgnoreCase := TRUE
    ELSE
      EqualsIgnoreCase := FALSE;
  END;


  FUNCTION camelCase(words: ARRAY OF STRING; n: INTEGER): STRING;
    VAR
      i, j: INTEGER;
      s: STRING;

  BEGIN
    i := 0;
    s := '';

    WHILE (i < n) DO BEGIN

      IF (length(s)+length(words[i])) > high(s) THEN BEGIN
        camelCase := 'Error';
        Exit;
      END; (*if*)

      (*wörter prüfen*)
      j := 1;
      WHILE (j <= length(words[i])) DO BEGIN
        IF NOT ((words[i][j] IN ['a'..'z','A'..'Z','0'..'9'])) THEN BEGIN
          camelCase := 'Error';
          Exit;
        END; (*if*)
        inc(j);
      END; (*while*)
    
    IF (i = 0) THEN (*ersten Buchstaben klein schreiben*)
      words[i] := LowerCase(copy(words[i], 1, length(words[i])))
    ELSE  
      words[i] := UpCase(copy(words[i], 1, 1)) + LowerCase(copy(words[i], 2, (length(words[i])-1)));

    s := s + words[i];
    inc(i);
    END; (*while*)
    camelCase := s;
  END;
  
  VAR
    a: ARRAY[1..max] OF STRING;
    n: INTEGER;

BEGIN

  ReadStringArray(a, n);
  
  WriteLn;
  WriteLn('1. Wert ohne letztem Char: ', WithoutLastChar(a[1]));
  WriteLn('1./2. Wert gleich (Gorss/Kleinschreibung egal): ',                   EqualsIgnoreCase(a[1], a[2]));
  WriteLn('gesamtes Array geCamelCased > ', camelCase(a, n));

END.
```

<div class="page-break" style="page-break-before: always;"></div>
### 2.3 Tests

| Eingabe                                 | Beschreibung                                                          | Ausgabe                                   |
| --------------------------------------- | --------------------------------------------------------------------- | ----------------------------------------- |
| siehe Screenshot                        | allgemeiner Test aller Funktionen                                     | ![[Pasted image 20251122192250.png\|300]] |
| siehe Screenshot                        | EqualsIgnoreCase testen - funktioniert                                | ![[Pasted image 20251122192415.png\|300]] |
| siehe Screenshot                        | unerlaubtes Zeichen (!)                                               | ![[Pasted image 20251122192528.png\|300]] |
| random 200 Zeichen String 2x eingegeben | camelCase schlägt fehl, weil 400 Zeichen nicht in einen String passen | ![[Pasted image 20251122192939.png\|300]] |

<div class="page-break" style="page-break-before: always;"></div>

# 3) Kaffeeautomat

### 3.1 Lösungsidee

Der Großteil der Programmlogik wird in eine Unit verpackt.
Im Hauptprogramm wird wiederholt eine Eingabe durch den in der Unit definierten Datentyp "Coins" entgegengenommen und damit die Prozedur CoffeeButtonPressed() aufgerufen. Danach wird das berechnete Wechselgeld mit der Prozedur WriteCoins() ausgegeben. Je nach User-Input wird das Programm wiederholt oder beendet.

Die Prozedur CoffeeButtonPressed() ist in der Unit definiert. Nach Prüfung der Abbruchbedingungen wird mit der Funktion CalcChange das Rückgeld berechnet und zurückgegeben.
Die Funktion CalcChange berechnet das Wechselgeld aus dem Gesamtwert des eingeworfenen Betrages mittels Ganzzahldivision und Restauswertung. Dabei werden immer die größtmöglichen Münzen verwendet. Wenn kein Wechselgeld mehr verfügbar ist, wird der zusätzliche Fehlerparameter "error" auf true gesetzt.
In diesem Fall (wenn error = true) wird eine Fehlermeldung ausgegeben und ein globaler Counter wird erhöht. (Damit nach 3 errors der Automat auf out of service gestellt wird, wird am Anfang der Prozedur geprüft.) Ansonsten wird gemeldet, dass es Kaffee gibt. 
In jedem Fall wird dem Ausgangsparameter change das errechnete Wechselgeld zugewiesen.
Im Hauptteil der Unit wird das vorher vorhandene Wechselgeld initialisiert.

<div class="page-break" style="page-break-before: always;"></div>

### 3.2.1 Quellcode Unit

```pascal
UNIT Kaffeeautomat_unit;

INTERFACE
  TYPE
    Coins = RECORD
      cent10: INTEGER;
      cent50: INTEGER;
      cent100: INTEGER;
  END;

  PROCEDURE ReadCoins(VAR c: Coins);
  PROCEDURE WriteCoins(c: Coins);

  PROCEDURE CoffeeButtonPressed(input: Coins; VAR change: Coins);

IMPLEMENTATION

  VAR
    totalCoins: Coins;
    noChangeCounter: INTEGER;

  PROCEDURE ReadCoins(VAR c: Coins);
  BEGIN
    Write('10 cent coins > '); ReadLn(c.cent10);
    Write('50 cent coins > '); ReadLn(c.cent50);
    Write('100 cent coins > '); ReadLn(c.cent100);
  END;

  PROCEDURE WriteCoins(c: Coins);
  BEGIN
    WriteLn('10 cent coins > ', c.cent10);
    WriteLn('50 cent coins > ', c.cent50);
    WriteLn('100 cent coins > ', c.cent100);
  END;

  FUNCTION AddCoins(a, b: Coins): Coins;
    BEGIN
      AddCoins.cent10 := a.cent10 + b.cent10;
      AddCoins.cent50 := a.cent50 + b.cent50;
      AddCoins.cent100 := a.cent100 + b.cent100;
    END;

  FUNCTION SubtractCoins(a, b: Coins): Coins;
  BEGIN
    SubtractCoins.cent10 := a.cent10 - b.cent10;
    SubtractCoins.cent50 := a.cent50 - b.cent50;
    SubtractCoins.cent100 := a.cent100 - b.cent100;
  END;

  

  FUNCTION TotalValue(c: Coins): INTEGER;
  BEGIN
    TotalValue := c.cent10*10 + c.cent50*50 + c.cent100*100;
  END;

  FUNCTION CalcChange(c: Coins; VAR error: BOOLEAN): Coins;
    VAR
      change: Coins;
      ValueOfChange: INTEGER;
  
  BEGIN

    change.cent100 := 0; (*init*)
    change.cent50 := 0;
    change.cent10 := 0;

    totalCoins := AddCoins(totalCoins, c); (*Eingabe zu Totalcoins addieren, zum Stand aktualisieren*)

    ValueOfChange := TotalValue(c)-40; (*Kaffeepreis*)

    change.cent100 := change.cent100 + (ValueOfChange DIV 100);
    ValueOfChange := ValueOfChange MOD 100; (*Rest für die anderen Münzen*)
    WHILE change.cent100 > totalCoins.cent100 DO BEGIN
      dec(change.cent100);
      change.cent50 := change.cent50 + 2;
    END; (*while*)

    change.cent50 := change.cent50 + (ValueOfChange DIV 50);
    ValueOfChange := ValueOfChange MOD 50; (*Rest*)
    WHILE change.cent50 > totalCoins.cent50 DO BEGIN
      dec(change.cent50);
      change.cent10 := change.cent10 + 5;
    END; (*while*)

    change.cent10 := change.cent10 + (ValueOfChange DIV 10);

    IF change.cent10 > totalCoins.cent10 THEN BEGIN
      error := TRUE;
      inc(noChangeCounter);
      totalCoins := SubtractCoins(totalCoins, c);
      CalcChange := c;
    END ELSE BEGIN
      totalCoins := SubtractCoins(totalCoins, change);
      error := FALSE;
      noChangeCounter := 0;
      CalcChange := change;
    END; (*if*)
  END;

  PROCEDURE CoffeeButtonPressed(input: Coins; VAR change: Coins);
    VAR
      error: BOOLEAN;
  BEGIN

    IF noChangeCounter >= 3 THEN BEGIN
      change := input;
      WriteLn('Error - out of service (not enough coins)');
      (*WriteLn('Rückgeld: ', change);*)
      Exit;
    END;

    IF TotalValue(input) < 40 THEN BEGIN
      change := input;
      WriteLn('Zu wenig Geld, gibts keinen Kaffee. :(');
      (*WriteLn('Rückgeld: ');*)
      (*WriteCoins(change);*)
      Exit;
    END; (*if*)

    change := CalcChange(input, error);

    IF error THEN BEGIN (*error: kein Wechselgeld*)
      WriteLn('Sorry, nicht genug Rueckgeld. Du bekommst dein Geld zurueck');
      WriteLn()
    END ELSE
      WriteLn('Kaffeeeeee!');
  END;


(*Initialisation, only first time*)
BEGIN
  (*Wechselgeld*)
  totalCoins.cent10 := 10;
  totalCoins.cent50 := 5;
  totalCoins.cent100 := 0;

  noChangeCounter := 0;
END.
```

<div class="page-break" style="page-break-before: always;"></div>

### 3.2.2 Quellcode Hauptprogramm
```pascal
PROGRAM Kaffeeautomat_usingUnit;

USES
  Kaffeeautomat_unit;

VAR
  input: Coins;
  change: Coins;
  userInteraction: STRING;
  moreCoffee: BOOLEAN;

BEGIN

  moreCoffee := TRUE; (*init*)

  WHILE moreCoffee DO BEGIN

    WriteLn('Enter your input: ');
    ReadCoins(input);

    CoffeeButtonPressed(input, change);
    WriteLn;

    WriteLn('Here is your change: ');
    WriteCoins(change);

    WriteLn;

    WriteLn('Do you want another coffee? (y/n)');
    ReadLn(userInteraction);

    IF (Length(userInteraction) > 0) AND ((userInteraction[1] = 'y') OR (userInteraction[1] = 'Y')) THEN
      moreCoffee := TRUE
    ELSE
      moreCoffee := FALSE;

  END; (*while*)

END.
```

<div class="page-break" style="page-break-before: always;"></div>

### 3.3 Tests

| Eingabe (Münzen)            | Beschreibung                                                                                            | Ausgabe                                   |
| --------------------------- | ------------------------------------------------------------------------------------------------------- | ----------------------------------------- |
| 10c: 3<br>50c: 0<br>1 €: 0  | nicht genug Geld                                                                                        | ![[Pasted image 20251122184833.png\|250]] |
| 10c: 3<br>50c: 1<br>1 €: 0  | genug Geld, Wechselgeld                                                                                 | ![[Pasted image 20251122185038.png\|200]] |
| 10c: 10<br>50c: 0<br>1 €: 0 | genug Geld, viel Kleingeld (Automat soll große Münzen zurückgeben)                                      | ![[Pasted image 20251122185213.png\|200]] |
| 10c: 0<br>50c: 0<br>1 €: 1  | 6 Mal hintereinander eingeben, damit das Rückgeld leer ist (will immer 1 x 50c und 1 x 10c zurückgeben) | ![[Pasted image 20251122190134.png\|300]] |
| 10c: <br>50c: <br>1 €:      | noch 2x versuchen, um den state "out of service" zu triggern                                            | ![[Pasted image 20251122190314.png\|300]] |

