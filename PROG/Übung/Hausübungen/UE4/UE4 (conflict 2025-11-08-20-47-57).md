- [x] #prog UE4 ‚è´ ‚è≥ 2025-11-02 üìÖ 2025-11-12 ‚úÖ 2025-11-09

# 1 Plateau-Problem

## 1.1 L√∂sungsidee

- mit For-Schleife durchz√§hlen
- mit Hilfsvariable immer den letzten Wert speichern
- vergleichen
	- wenn gleich, dann Hilfsz√§hler inkrimentieren
	- wenn ungleich, Hilfsz√§hler auf 1 setzen
		- Hilfsz√§hler in einem Hilfsarray abspeichern

- Eigene Funktion definieren, die von einem n-stelligen array das Maximum ausgibt
	- mittels Z√§hlschleife von 1 bis n mit stellenweisem vergleich und immer schreiben des gr√∂√üeren Wertes

## 1.2 Quellcode
```pascal
PROGRAM PlateauProblem;


const
	max = 100;

TYPE
	IntArray = Array[1..max] of Integer; //h√§√§√§√§√§ ich wei√ü ja nicht wie lange
	
var
  ExampleArr: IntArray;
  n: integer;
  i: integer;

function MaximumOfArray(a: IntArray; n: integer): integer;
	var
		GreaterValue: integer;
	
	begin
		GreaterValue := a[1]; //init
		for i := 2 to n do //Zugriff auf vorherigen Wert
			begin
				if a[i] > GreaterValue then
					GreaterValue := a[i];
			
			end;
	
	
	MaximumOfArray := GreaterValue;
	end;

function Plateau(a: IntArray; n: integer): integer;
	var
		j: integer; //z√§hlt aneinanderfolgende Werte
		NumbersCounted: IntArray;
    //array[1..n] of integer; //zum Speichern der Anzahl an aneinanderfolgenden Werten
		
	begin
		j := 1; //init
		NumbersCounted[1] := 1; //init
		
		for i:= 2 to n do //erster Wert √ºberspringen weil auf vorherigen Wert zugegriffen wird
			begin
				// Wenn IntArray[i]=vorherWert, dann inc(j), else j := 1
				//j in Hilfsarray speichern, mit NumbersCounted[i] := j
				
				if (a[i] = a[i-1]) then
					begin
						inc(j);
						NumbersCounted[i] := j;
					end
				else
					j := 1;
			end; (*for*)
			
	Plateau := MaximumOfArray(NumbersCounted, n);
	
	end;


  begin
    Write('n: '); Readln(n);

    WriteLn('Gib jetzt die ', n, ' Zahlen f√ºr das Array ein:');
    WriteLn;

    //Zahlen ins array einlesen
    for i := 1 to n do
      ReadLn(ExampleArr[i]);   

    WriteLn('Plateau-Wert: ', Plateau(ExampleArr,n));
  end.
```


## 1.3 Tests




# 2 Das fehlende Element

## 2.1 L√∂sungsidee
L√∂sung erfolgt nach Anleitung in a)


## Quellcode
```pascal
program TheMissingElement;

const
	max = 100;
	
type
	IntArray = Array[1..max] of integer;
	

function ExistInArray(a: IntArray; len, num: integer): boolean;
	var
		j: integer;
	begin
	//durchsuchen mit while schleife f√ºr sofortigen Abbruch bei Fund
	
		j := 1; //init
		while a[j] <> num do //solange j hochz√§hlen bis Index=Arraywert
			j := j + 1;

		if j <= len then
			ExistInArray := True
		Else
			ExistInArray := False;


	end;




function MissingElement(a: IntArray; n: integer): integer;
	var
		h: array[1..max] of boolean;
		i, k: integer;
		
	begin
		//h init
		for i := 1 to (n+1) do
			a[i] := false;
			
		//pr√ºfen, ob Index vom Feld im Array vorkommt
		for i := 1 to (n+1) do
			begin
				if ExistInArray(a, n, i) then
					h[i] := true;
			end;
			
		//h durchlaufen und beim ersten False aufh√∂ren, Index --> Ergebnis
		k := 1; //init
		
		repeat
			k := k + 1;
		until h[k] = false;
		
		MissingElement := k;

	end;
```


## Das fehlende Element b)

### L√∂sungsidee

Eine Schleife pr√ºft immer, ob eine Z√§hlvariable (startend bei 1) im Array enthalten ist oder nicht. Wenn sie enthalten ist, wird die Z√§hlvariable um eins erh√∂ht. Wenn sie nicht enthalten ist, so ist das offensichtlich der fehlende Wert. Dazu wird eine Hilfsfunktion inArray(i,a,n) verwendet, welche zuerst definiert wird.

```pascal
program TheMissingElement;

const
	max = 100;
	
Type
	IntArray = array[1..max] of integer;

function inArray(num: integer; a: IntArray; n: integer): boolean;
var
	found: boolean;
	i: integer;
begin
	//Array mit Schleife durchlaufen so lange vergleichen bis gefunden
	found := false; //init
	i := 1; //init
	while (i <= n) and (not found) do
		begin
			if num = a[i] then
        begin
				  found := true;
        end
			else
        begin
				  found := false;

        end;
      i := i + 1;
		end;

    inArray := found;
end;




function MissingElement(a: IntArray; n: integer): integer;
var
	i: integer;
begin

	i := 1; //init
	
	//wenn i nicht im Array enthalten ist, ist es der gesuchte Wert
	while inArray(i,a,n) do
		begin
			i := i + 1;
		end;
	
	MissingElement := i;
end;

var
  n, i: integer;
  a: IntArray;
  
begin
  //read in array
  Write('n: ');
  ReadLn(n);
  WriteLn('Enter the values of your array: ');
  WriteLn;
  for i := 1 to n do
  begin
      ReadLn(a[i]);
  end;
  
  WriteLn('The missing element is ', MissingElement(a,n));

end.
```
























